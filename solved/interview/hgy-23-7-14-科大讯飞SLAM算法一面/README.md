## 科大讯飞SLAM算法一面

### 项目

1. 介绍多传感器融合SLAM的项目

* 狠狠地问了局部里程计的卡尔曼滤波融合的部分，我项目中直接相信了imu的角速度积分作为资态，轮速计的航机推算作为位置。系统方程是静止的模型，这个给面试官翻代码的时候发现了。融合这部分还是需要好好想想，系统方程应该用imu来做恐怕合理一点。但其实robot_ekf也是和我的做法差不多的。

* 怎么判断激光退化场景

我答的两个方面，要么判断场景的点云分布很接近，导致运动无法产生明显区别。可以设计算法判断相邻点云的相似性。要么就是场景特征太少，约束不够，可以参考张继对姿态求解过程中的矩阵的特征值入手，找到特征值对应较小的退化方向，抑制解在这个退化方向上的发散。

* 有没有测试过NDT和基于LOAM的点云配准方法哪种好？
各有优劣。在初值相对不准确的情况下，NDT明显会有更鲁棒和更快收敛的效果，但计算量相对较大。在初值靠谱的情况下，icp效率更高。

2. 说以下LOAM系列和LIOSAM区别。

LOAM：纯激光里程计
Lego-LOAM：点线特征优化xyyaw, 点面特征优化rpz,带有后端。
LIO-SAM: 带有惯性传感器，带有后端，并且使用imu进行点云去畸变。

### C++八股

1. 指针和引用的区别？
https://zhuanlan.zhihu.com/p/140966943

主要的几个：
* 引用是别名，指针是变量。
* 引用使用时要原地初始化，指针不需要。
* 引用只有一级，指针有多级。

2. delete和delete[] 的区别。
https://zhuanlan.zhihu.com/p/111501118
delete和delete[] 对于普通类型对象的释放并没区别。但对于类对象，而且成员有另外申请动态内存的指针，它的内存释放在类的析构函数中实现，这时混用就会产生内存泄漏。

```c++
class A{
    int *p;
public:
    A() { p = new int[10]; }
    // 这里用delete 和 delete[] 都ok
    ~A() { delete p; }
};

int main()
{
    A* a = new A[10];
    delete[] a; // 这里只能用delete[]，否则只会释放a[0]的内存和析构函数，delete[] 确保数组所有对象的析构函数都被调用。
    return 0;
}
```

3. 说以下多线程和信号量。
信号量：https://www.cnblogs.com/wuyepeng/p/9748552.html
用于进程间或者多线程的互斥和同步。相当于计数器，计数器大于0，则进程可操作资源，计数器减1，当计数器为0时，进程再次申请时将阻塞。进程离开临界区时，计数器加一。

4.  多线程调试方法。

valgrind定位内存泄漏，尽量少用裸指针。

gdb 定位死锁：
https://www.cnblogs.com/wangshaowei/p/14212892.html
